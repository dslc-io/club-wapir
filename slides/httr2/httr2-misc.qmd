---
engine: knitr
title: Do more with {httr2}
---

# TODO

::: nonincremental
-   Cover req_throttle() & req_timeout() in here
-   Most likely: Merge into httr2-methods.
:::


# ️✅ Learning objectives

::: nonincremental
-   Perform a list of {httr2} requests in sequence.
-   Perform a list of {httr2} requests in parallel.
-   Stream data from an API. `r lifecycle::badge("questioning")`
:::

```{r}
#| label: httr2-misc-packages-used
#| eval: true
library(httr2)
```

::: notes
"After we finish this chapter, we'll be able to..." (objectives)
:::

## Controlling large requests

-   `httr2::req_progress()` adds a progress bar for requests that transfer a lot of data.
-   `httr2::req_timeout()` to add a maximum wait time in seconds
-   `httr2::req_cache()` to avoid re-calling slow calls

## Throttling and retries

-   APIs often throw errors if hit too fast
-   `httr2::req_throttle()` to slow down
    -   `realm` when endpoints have different limits ("Tier 1" vs "Tier 2")
-   `httr2::req_retry()` to try again for transient failures
    -   Default: Statuses 429 & 503 = transient
    -   (optional) `is_transient` function to override
    -   (optional) `after` function to extract wait from response

## Dealing with errors

-   `httr2::req_error()` to handle errors
    -   `is_error` function to escalate something to an error
        -   *Eg: Empty response you know isn't really empty*
    -   `body` function to parse response into `rlang::abort()` message.
        -   *Eg: API description gives details of an error code's meaning*

## Multiple requests

-   Manually create list of separate requests
-   Perform all:
    -   `httr2::req_perform_parallel()` all at once
        -   No reauth, no throttle, no retry, no cache
    -   `httr2::req_perform_sequential()` serially
        -   Slower but can use other settings

## Multiple requests: YouTube

Get 10 most recent videos from list of playlists.

```{r}
#| label: httr2-misc-multiple-requests
base_req <- request("https://youtube.googleapis.com/youtube/v3") |> 
  req_url_path_append("playlistItems") |> 
  req_url_query(part = "contentDetails", maxResults = 10) |> 
  req_auth_bearer_token(IGNORE_FOR_NOW)

resps <- purrr::map(
  playlists, \(playlist) req_url_query(base_req, playlistId = playlist)
) |> 
  req_perform_parallel() # or req_perform_sequential()
```

## Streaming

-   `httr2::req_perform_stream()` to stream data from API
-   Blocks R session (see Chapter 10 for alternative)
-   Call function every `buffer_kb` kilobytes
-   *Eg: Save to file, different process could read that file from Shiny*

## Streaming: Simple example

```{r}
#| label: httr2-misc-streaming
show_bytes <- function(x) {
  cli::cli_inform("Got {length(x)} bytes at {Sys.time()}.")
  TRUE
}
resp <- httr2::request(httr2::example_url()) |>
  httr2::req_url_path("/stream-bytes/100000") |>
  httr2::req_perform_stream(show_bytes, buffer_kb = 32)
```

## Is this interesting?

-   `req_options()` lets you directly set libcurl options not available in {httr2}
-   Should I dig through and find what's available but not implemented?
