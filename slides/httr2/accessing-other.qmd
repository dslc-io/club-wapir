---
engine: knitr
title: Communicate with other types of APIs
---

# ️✅ Learning objectives

::: nonincremental
-   Fetch data from GraphQL APIs.
-   Fetch data from websocket APIs.
-   Fetch data from gRPC APIs.
:::

```{r}
#| label: req-other-setup
library(ghql)
library(jsonlite)
library(dplyr)
library(httr2)
library(websocket)
library(protolite)
# library(RProtoBuf)
```

# GraphQL

## What is GraphQL?

-   "Open-source data query and manipulation language"
    -   `query` = data you need
    -   `mutation` = new data to add
    -   JSON-like format
    -   1 endpoint
-   Developed by Facebook
-   Used by [Facebook](https://developers.facebook.com/docs/graph-api/), [GitHub](https://docs.github.com/en/graphql), [Yelp](https://docs.developer.yelp.com/docs/graphql-intro), [Shopify](https://shopify.dev/docs/apps/build/graphql), etc

::: notes
-   Think of it as a REST API with 1 endpoint and strict rules about what goes into the request body.
-   Might get a chapter in my next iteration.
-   Intended to allow you to filter for the data you need.
    -   Could really use a dplyr implementation!
:::

## GraphQL in R

-   Client side: [{ghql}](https://docs.ropensci.org/ghql/index.html)
-   Server side: [{gqlr}](http://schloerke.com/gqlr/index.html)

::: notes
-   Current landscape feels like "I use GraphQL in other languages, and want it to technically be possible to do so from R."
-   We'll go through a {ghql} example
:::

## Country data: setup

-   [Countries GraphQL API](https://github.com/trevorblades/countries)

::: fragment
```{r}
#| label: req-other-graphql-setup
ghql_con <- ghql::GraphqlClient$new(url = "https://countries.trevorblades.com/")
qry <- ghql::Query$new()
```
:::

::: notes
-   UpperCamelCase + `$new()` means this uses R6. 
    -   See Advanced R to get started
:::

## Country data: query

::::: columns

:::: column
```{r}
#| label: req-other-graphql-query
qry$query("country_data",
  "query($code: [String!]) {
     countries(
       filter: {code: {in: $code}}
     ) {
       code
       name
       capital
       phone
       languages {
         code
         name
       }
     }
   }"
)
```
::::
:::: column
```{r}
#| label: req-other-graphql-query-comments
# name of this query
# define variables
#
#
# Select countries using codes
#
# fields we want for each country
```

-   No commas
-   No quotation marks
::::
:::::

::: notes
-   "[String!]" means "Array of non-nullable (required) strings".
-   Schema specifies data types
-   Could filter by more things (like dplyr filter)
    -   Schema specifies code, continent, currency, name
:::

## GraphQL response {-}

```{r req-other-graphql-response, eval = FALSE}
country_codes <- list(code = c("US", "DE"))
x <- ghql_con$exec(
  qry$queries$country_data,
  country_codes
) # We created a query named "country_data"
jsonlite::fromJSON(x)
#> $data
#> $data$countries
#>   code          name         capital phone   languages
#> 1   DE       Germany          Berlin    49  de, German
#> 2   US United States Washington D.C.     1 en, English
```

## websocket review {-}

-   Alternative to HTTP
-   `ws://` or `wss://`
-   2-way communication
-   {websocket} package

## Aside: shiny & websockets {-}

-   You might see websocket-related errors in Shiny
-   Shiny UI & server communicate via a websocket connection
-   More directly managed via {httpuv} & TypeScript code
-   Beyond the scope of this book

## websocket demo: setup {-}

```{r req-other-websocket-setup, eval = FALSE}
ws <- WebSocket$new("ws://echo.websocket.events/", autoConnect = FALSE)
ws$onMessage(\(event) {
  now <- format(Sys.time(), digits = 0)
  cat("Client got msg:", event$data, "at", now, "\n")
})
```

## websocket demo {-}

```{r req-other-websocket-demo, eval = FALSE}
ws$connect()
#> Client got msg: echo.websocket.events sponsored by Lob.com at 2023-11-15 2023-11-15 08:28:04
# (can do other things in console now)
1
#> [1] 1
ws$send("hello")
#> Client got msg: hello at 2023-11-15 08:28:10
ws$close()
```

## websocket: toward usefulness {-}

```{r req-other-websocket-setup2, eval = FALSE}
ws_counter <- 1
ws2 <- WebSocket$new("ws://echo.websocket.events/", autoConnect = FALSE)
ws2$onMessage(\(event) {
  ws_counter <<- ws_counter + 1 # Add 1 to global ws_counter var 
  cat(ws_counter, "\n")
})
ws_counter
#> 1
ws2$connect()
#> 2
ws2$send("update")
#> 3
ws2$send("update again")
#> 4
ws2$close()
```

## websocket usecases {-}

-   News/Message feeds
    -   Display new content as it comes in
-   Messaging
    -   Send and receive ~simultaneously without new connections
-   Multi-player games
-   Collaborative editing
-   Real-time dashboards

## gRPC review {-}

-   Google Remote Procedure Call
-   Becoming very popular
-   Good for real-time, 2-way communication
-   Uses HTTP/2 (more socket-like)

## gRPC: What is it really? {-}

-   HTTP/2 (upgraded HTTP)
    -   Can access via {httr2}
-   "Protocol buffers" datatype
    -   Fully implemented in {RProtoBuf} package
    -   {protolite} for basics

## gRPC demo {-}

From [RProtoBuf paper](https://www.jstatsoft.org/article/view/v071i02)

```{r req-other-grpc, eval = FALSE}
resp <- request("https://demo.ocpu.io/MASS/data/Animals/pb") |> 
  req_perform()
output <- resp_body_raw(resp) |> 
  unserialize_pb() # This is the important part
identical(output, MASS::Animals)
#> [1] TRUE
head(output)
#>                     body brain
#> Mountain beaver     1.35   8.1
#> Cow               465.00 423.0
#> Grey wolf          36.33 119.5
#> Goat               27.66 115.0
#> Guinea pig          1.04   5.5
#> Dipliodocus     11700.00  50.0
```

## gRPC demo2: R via API {-}

```{r req-other-grpc-post, eval = FALSE}
args <- list(n = 5, mean = 100)
payload <- serialize_pb(args, connection = NULL)
resp <- request("https://cloud.opencpu.org/ocpu/library") |> 
  req_url_path_append("stats", "R", "rnorm", "pb") |> 
  req_body_raw(payload, type = "application/protobuf") |>
  req_perform()

resp_body_raw(resp) |> 
  unserialize_pb()
#> [1] 102.61489 101.70467  99.12647  99.85958 100.47736
```
