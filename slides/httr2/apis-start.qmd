---
engine: knitr
title: How can I get started with APIs?
---

# ️✅ Learning objectives

::: nonincremental
-   Read API docs.
-   Fetch json-formated data from the web.
-   Fetch yaml-formatted data from the web.
-   Parse nested lists with the {tidyverse}.
-   Use an API's OpenAPI specification to learn about the API.
-   Parse nested lists with {tibblify}.
:::

```{r}
#| label: apis-start-packages-used
#| eval: true
library(dplyr)
library(jsonlite)
library(purrr)
library(tibble)
library(tibblify)
library(tidyr)
library(yaml)
```

::: notes
-   Pretend this is our second meeting. Chapter 1 talked about what APIs are, but we haven't done httr2 yet.
-   Has anybody used:
    -   nested lists (unnest)
    -   tibble::enframe()
    -   tibblify
:::

# Where can I find APIs?

![](/images/apisguru.png)

::: notes
-   I'm very likely going to build a replacement for APIs.guru.
    -   Doesn't update often enough.
    -   Most recent merge: March 8, 2023
    -   It should live up to its name, and be easier to update!
-   But principles will still hold!
:::

## Browsing APIs.guru

([launch APIs.guru to explore](https://apis.guru/))

-   Good if you know what you're looking for
-   Less good for exploration
-   But we can grab the data directly!

## The APIs.guru API

-   ([launch APIs.guru API page to explore](https://apis.guru/api-doc/#operation/listAPIs))
-   ([list.json result](https://api.apis.guru/v2/list.json))

::: notes
-   JSON = JavaScript Object Notation
-   By far most common format for API data
-   I'm using [JSONVue browser extension](https://chromewebstore.google.com/detail/jsonvue/chklaanhfefbnpoihckbnefhakgolnmc?pli=1) 
-   Great for nested data
-   We aren't going to dig into the format because we won't use it directly
:::

## List all APIs.guru APIs

::: fragment
```{r}
#| label: apis_start-apis_guru_list
all_apis <- jsonlite::fromJSON("https://api.apis.guru/v2/list.json")
```
:::

```{r}
#| label: apis_start-apis_guru_list_download
#| eval: false
#| include: false
download.file(
  "https://api.apis.guru/v2/list.json",
  here::here("slides", "httr2", "apis-start", "list.json")
)
```
```{r}
#| label: apis_start-apis_guru_list_load
#| eval: true
#| include: false
all_apis <- jsonlite::fromJSON(here::here("slides", "httr2", "apis-start", "list.json"))
```

::: fragment
```{r}
#| label: apis_start-apis_guru_list_length
#| eval: true
length(all_apis)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_head
#| eval: true
head(names(all_apis))
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_depth
#| eval: true
purrr::pluck_depth(all_apis)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_str
#| eval: true
str(head(all_apis, 2), max.level = 2)
```
:::

::: notes
-   jsonlite = one of several packages for parsing JSON
    -   We'll stick with it because it works & is used by higher-level packages
    -   Used in {shiny}, {httr}, {httr2}, dozens of other packages
-   fromJSON does some automatic guessing, we'll come back to this in a later chapter
    -   Alternatives: read_json reads file, parse_json reads string; don't guess by default 
-   This result is a huge, nested list
-   purrr::pluck_depth() tells you how nested a list is
-   hard to see this. Let's rectangle it!
:::

# Rectangling data

-   "Rectangling" = converting hierarchical data to data frame
-   Some background in [R4DS Chapter 23: "Hierarchical data"](https://r4ds.hadley.nz/rectangling.html)
    -   But we'll use different methods
-   Trial-and-error = ok

::: notes
-   Rectangular data is nice because then you can use normal tidyverse functions
-   There's a tidyverse function that I think handles returns from APIs better than what they show there.
-   You might need to play around with unnest_wider vs unnest_longer (we'll see examples in a sec). Don't feel like you're doing something wrong!
-   In a couple chapters, we'll see how to use the API spec (when it's available) to help us guess less.
:::

## Rectangling APIs.guru's list

::: fragment
```{r}
#| label: apis_start-apis_guru_list_df
#| eval: true
#| code-line-numbers: 1-2|2
all_apis_df <- all_apis |>
  tibble::enframe(name = "api_name")
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_df2
#| eval: true
all_apis_df
```
:::
::: notes
-   `tibble::enframe()` is underused, imo!
-   Best with named lists
-   `name` arg is often useful (if input is named)
    -   If it isn't named, set to NULL
-   `value` arg is available but we're almost always going to destroy that column
-   Need to figure out whether those values are blocks of results (rows) or separate pieces of information about a single result (columns)
:::

## Unnest wider or longer?

::: fragment
```{r}
#| label: apis_start-apis_guru_list_df_explore
#| eval: true
all_apis_df$value |> lengths() |> unique()
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_df_explore2
#| eval: true
all_apis_df$value[[1]] |> names()
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_df_explore3
#| eval: true
setdiff(
  names(all_apis_df$value[[1]]),
  names(all_apis_df$value[[11]])
)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_df_explore4
#| eval: true
str(all_apis_df$value[1:2], max.level = 2)
```
:::

::: notes
-   Wider if multiple variables per value, longer if multiple observations per value.
-   (make sure everyone groks why wider)
:::

## Our first unnest

::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions
#| eval: true
all_apis_versions <- all_apis_df |>
  tidyr::unnest_wider(value)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions2
#| eval: true
all_apis_versions
```
:::

::: notes
-   `tidyr::unnest_auto()` will guess, sometimes useful (but replace in final code)
-   Why not just `unnest()`?
    -   Useful if the column contains identically structured dfs (unnests to cols and rows)
    -   Loses names and can otherwise make a mess if we aren't careful.
:::

## Unnest 2: wider or longer?

::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions_explore
#| eval: true
all_apis_versions$versions |> lengths() |> unique()
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions_explore2
#| eval: true
all_apis_versions$versions |> lengths() |> head(10)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions_explore3
#| eval: true
all_apis_versions$versions[[1]] |> names()
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions_explore4
#| eval: true
all_apis_versions$versions[[10]] |> names()
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_versions_explore5
#| eval: true
all_apis_versions$versions[[10]] |> str(max.level = 1)
```
:::

## Unnest 2

::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred
#| eval: true
#| code-line-numbers: 1-2|3|4
all_apis_preferred <- all_apis_versions |>
  tidyr::unnest_longer(versions, indices_to = "version") |>
  dplyr::filter(preferred == version) |>
  dplyr::select(api_name, version, versions)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred_print
#| eval: true
all_apis_preferred
```
:::

## Unnest 3: wider or longer?

::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred_explore
#| eval: true
all_apis_preferred$versions |> lengths() |> unique()
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred_explore2
#| eval: true
setdiff(
  names(all_apis_preferred$versions[[7]]),
  names(all_apis_preferred$versions[[1]])
)
```
:::
::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred_explore3
#| eval: true
all_apis_preferred_wide <- all_apis_preferred |>
  tidyr::unnest_wider(versions)
```
:::

## All APIs

::: fragment
```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred_wide
#| eval: true
#| code-line-numbers: 1|2|3|4|5-6|7
all_apis |> 
  tibble::enframe(name = "api_name") |> 
  tidyr::unnest_wider(value) |> 
  tidyr::unnest_longer(versions, indices_to = "version") |>
  dplyr::filter(preferred == version) |>
  dplyr::select(api_name, version, versions) |>
  tidyr::unnest_wider(versions)
```
:::

::: notes
-   If we dug in a little more, we'd see that info is variable-like, but all over the place; different APIs have different values
    -   APIs.guru adds a couple things in here, including a "category" that we'll use
:::

## Filter APIs

```{r}
#| label: apis_start-apis_guru_list_all_apis_preferred_wide_filter
#| eval: true
#| code-line-numbers: 1-2|3-5
all_apis_preferred_wide |>
  tidyr::hoist(info, categories = "x-apisguru-categories") |>
  dplyr::rowwise() |>
  dplyr::filter("open_data" %in% categories) |>
  dplyr::ungroup()
```

::: notes
-   Could also unnest_longer and filter for "open_data"
-   `swaggerUrl` is JSON, `swaggerYamlUrl` is YAML version of the same thing
-   YAML is another data format. Technically YAML is a superset of JSON, with added commenting capabilities.
-   RMarkdown headers + package descriptions are YAML-related.
-   We mostly don't care (mostly because YAML plays slightly better with tibblify, as we'll see)
-   "Swagger" is the old name for the OpenAPI specification, a standard way to describe APIs.
-   Not everyone uses swagger/OpenAPI, but, when they do, your life is easier
:::

# API Definitions

## API Descriptions

-   [APIs.guru](https://api.apis.guru/v2/specs/apis.guru/2.2.0/openapi.json)
-   [OpenFEC](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.json)
-   [YouTube Data API v3](https://api.apis.guru/v2/specs/googleapis.com/youtube/v3/openapi.json)
-   [Asana](https://api.apis.guru/v2/specs/asana.com/1.0/openapi.json)

::: notes
-   Technically the OpenAPI specification is the standard, and each API has a "description"
-   OpenAPI 3.0+ easier to use than Swagger (aka 2.0)
-   Still some confusing bits, such as `security` vs `components$securitySchemas`
-   People can and will do things wrong/weird.
:::

## Read an API description

```{r}
#| label: apis_start-api_spec-download
#| eval: false
#| include: false
download.file(
  "https://api.apis.guru/v2/specs/googleapis.com/youtube/v3/openapi.yaml",
  here::here("slides", "httr2", "apis-start", "youtube.yaml")
)
```
```{r}
#| label: apis_start-api_spec-load
#| eval: true
#| include: false
youtube_spec <- yaml::read_yaml(here::here("slides", "httr2", "apis-start", "youtube.yaml"))
```

::: fragment
```{r}
#| label: apis_start-api_spec
youtube_spec <- yaml::read_yaml("https://api.apis.guru/v2/specs/googleapis.com/youtube/v3/openapi.yaml")
```
:::
::: fragment
```{r}
#| label: apis_start-api_spec-examine
#| eval: true
names(youtube_spec)
```
:::

## Introduction to tibblify

```{r}
#| label: apis_start-api_spec-tibblify
#| eval: true
youtube_paths <- tibblify::tibblify(youtube_spec$paths) |> 
  dplyr::glimpse()
```

## OpenAPI References

```{r}
#| label: apis_start-api_spec-tibblify-ref
#| eval: true
youtube_paths$parameters[[1]]
```

## parse_openapi_spec()

```{r}
#| label: apis_start-api_spec-tibblify-openapi
#| eval: true
youtube_paths <- tibblify::parse_openapi_spec(youtube_spec)
```
::: fragment
```{r}
#| label: apis_start-api_spec-tibblify2
#| eval: true
youtube_paths
```
:::

::: notes
-   We're looking at a dev version of tibblify which I plan to push through
    -   `pak::pak("mgirlich/tibblify#191")`
-   "endpoint" is another term for "path" -- a url in the API
-   Deals with references from paths to components > schemas
-   Captions has 4 different methods, so its tibble has 4 rows.
:::

## Unnesting paths

```{r}
#| label: apis_start-api_spec-tibblify3
#| eval: true
youtube_paths |> tidyr::unnest(operations)
```

::: notes
-   `operation` aka method, we'll discuss these more later; GET means you can load it like a web page
-   Note rows 3-6 are that `captions` endpoint, and then 7 is `captions/{id}`
:::

## Path details

```{r}
#| label: apis_start-api_spec-tibblify4
#| eval: true
youtube_paths |> tidyr::unnest(operations) |> dplyr::glimpse()
```

::: notes
-   (`endpoint` = path)
-   (`operation` = `method` = more details in a few chapters)
-   `summary` is meant for a very brief description, not often used
-   `description` can have markdown
-   `operation_id` = unique string for this operation, meant for tools to use as a function name
-   `tags` = Categories; can have more than one per endpoint, but often just one
-   `parameters` = tibble of inputs
-   `request_body` = tibble of a fancier type of input (later chapter)
-   `responses` = tibble of expected output
-   `deprecated` = is this endpoint no longer intended to be used
-   `global_parameters` = tibble of shared inputs
-   This tibble contains MOST of the useful information about the API
    -   We'll dig into this tibble for a simple API in the next chapter
:::

# Survey

[Please let me know what you think about this chapter!](https://forms.gle/jiq4jsaXV6accnNS6)

::: notes
https://forms.gle/jiq4jsaXV6accnNS6
:::
