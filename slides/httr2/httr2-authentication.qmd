---
engine: knitr
title: How do I tell the API who I am?
---

# ️✅ Learning objectives

::: nonincremental
-   Provide information in your request about how you're accessing the API. 
-   Find authentication information in API docs.
-   Authenticate a request with an API key.
-   Authenticate a request with OAuth.
:::

```{r}
#| label: authentication-packages-used
#| eval: true
#| warning: false
library(httr2)
```

# How can I tell the API how I'm accessing it?

## What is a user agent?

-   "User agent" = software that accesses the web
-   `User-Agent` request header = string IDing the "user agent"
    -   Request header = extra info sent with request
-   {httr2} attaches a default `User-Agent` header

::: fragment
```{r}
httr2::request("https://example.com") |> httr2::req_dry_run()
#> GET / HTTP/1.1
#> Host: example.com
#> User-Agent: httr2/1.0.1 r-curl/5.2.1 libcurl/8.3.0
#> Accept: */*
#> Accept-Encoding: deflate, gzip
```
:::

::: notes
-   It's arguable whether *your code* is the user agent or *httr2* is.
-   Headers are the things at the top of a request, outside the request itself
    -   Usually what you're expecting back + user agent
:::

## Should I override the default user agent?

-   Are you hitting the API ***a lot?***
-   Are you providing reusable code for others to hit the API?
-   Does the API documentation mention it?

::: notes
-   Default is fine almost all the time
-   Include UA in package (with option for user to expand)
-   If you use your code repeatedly/automatically, provide a UA
-   Documentation might ask for it (like Jim found in api.crossref.org docs)
:::

## How do I override the default user agent?

`httr2::req_user_agent(req, string = NULL)`

```{r}
#| label: httr2-authentication-req_user_agent
httr2::request("https://example.com") |> 
  httr2::req_user_agent("MyUserAgent/1.0 (more details; separate with ;)") |> 
  httr2::req_dry_run()
#> GET / HTTP/1.1
#> Host: example.com
#> User-Agent: MyUserAgent/1.0 (more details; separate with ;)
#> Accept: */*
#> Accept-Encoding: deflate, gzip
```

::: notes
-   Convention is Software slash version,
-   Details in parentheses,
-   Separate with ;
-   But can be any string
:::

## An experimental .Rprofile user agent function

```{r}
#| label: httr2-authentication-.req_ua
.httr2_ua <- function() {
  # Recreate the default httr2 string.
  versions <- c(
    httr2 = as.character(utils::packageVersion("httr2")),
    `r-curl` = as.character(utils::packageVersion("curl")),
    libcurl = curl::curl_version()$version
  )
  paste0(names(versions), "/", versions, collapse = " ")
}
.req_ua <- function(req) {
  httr2_string <- .httr2_ua()
  me <- "Jon Harmon"
  url <- "https://wapir.io"
  email <- "jonthegeek+useragent@gmail.com"
  string <- glue::glue(
    "{httr2_string} ({me}; {url}; mailto:{email})"
  )
  httr2::req_user_agent(req, string = string)
}
```

::: notes
-   usethis::edit_r_profile()
-   Start with `.` so it doesn't show in my environment.
-   In general, UA should tell the API how you're accessing it
-   I'll likely put a version of this into {nectar} soon.
:::

# How can I find authentication information?

## What is authentication?

-   **Authentication:** Verifying who you are.
-   **Authorization:** Granting permissions to do things (based on authentication)
-   **Auth:** Used interchangeably for both

::: notes
-   Internet makes a big deal about this distinction if you Google
-   For users, the difference doesn't matter
    -   You auth with the server so the server will auth you
:::

## What are some types of authentication?

::: fragment
🔴 **HTTP Basic:** username + password sent with request
:::
::: fragment
|         📜 *deed to your house*
:::
::: fragment
🟠 **API Key:** password-like thing sent with request
:::
::: fragment
|         🔑 *key to your house*
:::
::: fragment
🟡 **Bearer Token:** shorter-lived, limited key
:::
::: fragment
|         💳 *keycard*
:::
::: fragment
🟢 **OAuth:** multistep process to generate a key
:::
::: fragment
|         🕵️ *background check to issue keycard*
:::
::: fragment
|         🕵️ *background check to issue keycard **to a friend***
:::

::: notes
-   Almost nobody uses HTTP basic for APIs anymore.
-   If you gave an ex a key to your house, you can change the lock without disrupting your life too much
-   Nothing enforces difference between bearer tokens and api keys; it's a vocabulary thing, which API makers might screw up
-   Keycard can be limited to open certain doors, not open others
-   End result of OAuth is a bearer token
-   The "friend" might be you, might be someone else's package
-   A lot of the complexity is making sure you trust the software that's acting on your behalf
-   There are other things, but these four cover almost everything.
-   Other schemes like api keys in cookies, SSL certs not discussed here
:::

## API Auth Documentation

-   Sadly, no standard
-   [OpenFEC](https://api.open.fec.gov/developers)
-   [Google Calendar](https://developers.google.com/calendar/api/guides/overview)

::: notes
-   Usually either at top of docs or in each relevant endpoint
-   Sometimes different endpoints have different requirements (particularly OAuth scopes, more below)
    -   This endpoint only requires read, this one requires read and write
-   Often docs give the basics, but might not have all details for actually using OAuth in code, for example.
:::

## OpenAPI: securitySchemes

If you have the OpenAPI description, use it!

-   `components$securitySchemes` = ways to auth
-   `security` (top level) = default schemes
-   [OpenFEC](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.yaml)
-   [Google Calendar](https://api.apis.guru/v2/specs/googleapis.com/calendar/v3/openapi.yaml)

::: notes
-   Often still necessary to dig through docs for details
-   I suspect the 2 "apiKey in query" schemes for OpenFEC are the default key vs a user-specific key, their way of implementing scopes.
-   In your code, if you have option of header vs query, use header (slight more)
:::

# How can I prepare my system for authentication?

## Practice safe git

-   Run `usethis::git_vaccinate()`
-   Often `usethis::use_git_ignore(".Renviron")`

::: notes
-   `git_vaccinate()` "Adds `Rproj.user`, `.Rhistory`, `.Rdata`, `.httr-oauth`, `.DS_Store`, and `.quarto` to your global (a.k.a. user-level) `.gitignore`."
-   httr2 actually puts auth info in a more-secure, harder-to-check-in place.
-   We'll often put keys in personal .Renviron, but you might want a project-specific one for special keys.
-   Even better: use {keyring} (TODO: Go down this rabbit hole!)
:::

## Use keyring

-   `install.packages("keyring")`
-   `keyring::key_set(service)`
-   `keyring::key_set_with_value(service, password = NULL)`
-   `keyring::key_get(service)`
-   May need to copy keyring to env for packages
    -   `Sys.setenv(FEC_API_KEY = keyring::key_get("FEC_API_KEY"))`

::: notes
-   {keyring} works with your operating system's key manager
-   `key_set()` has you enter the key in a secure password window
-   `key_set_with_value()` useful if a function fetches a key (you never need to see it)
-   `key_get()` returns that key
:::

# How can I authenticate a request using API keys?

## Where do I put API keys?

-   `in: query`
    -   `httr2::req_url_query(.req, ...)`
-   `in: header`
    -   `httr2::req_headers(.req, ..., .redact = NULL)`
    -   `.redact` = character vector of headers to hide in print
-   `in: cookie`
    -   `httr2::req_headers(.req, Cookie = "name=val1; name2=val2", .redact = "Cookie")`

::: notes
-   APID does a good job of describing where these can go.
-   Header more secure than query, so use that when available
-   `...` = name-value pairs, case-insensitive (but usually just copy-paste from docs).
-   Cookies are meaningful in the browser, but for your code it's easiest just to think of them as a type of header.
:::

## How can I authenticate FECAPI requests?

[OpenFEC OAS](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.yaml)

```{r}
request("https://api.open.fec.gov/v1") |> 
  req_headers("X-Api-Key" = "DEMO_KEY", .redact = "X-Api-Key")

#> <httr2_request>
#> GET https://api.open.fec.gov/v1
#> Headers:
#> • X-Api-Key: '<REDACTED>'
#> Body: empty
```

## Authenticating with nectar

[{nectar}](https://nectar.api2r.org) 📦 wraps {httr2} for packages

```{r}
request("https://api.open.fec.gov/v1") |> 
  nectar::req_auth_api_key(
    location = "header", 
    parameter_name = "X-Api-Key", 
    api_key = "DEMO_KEY"
  )

#> <httr2_request>
#> GET https://api.open.fec.gov/v1
#> Headers:
#> • X-Api-Key: '<REDACTED>'
#> Body: empty
```

::: notes
-   Part of purpose of {nectar} is to translate between APID and {httr2}.
:::

# How can I authenticate a request using OAuth?

-   Next week!
-   Slides still in progress.
-   Also see [httr2 OAuth article](https://httr2.r-lib.org/articles/oauth.html)

## Oauth terminology

| term(s)        | meaning                             |
|----------------|-------------------------------------|
| **user**       | the person who you're acting as     |
| application, **app** | your R code |
| **client**, oauth application | you create this at oauth host |
| oauth **host** | the API, or a 3rd party like Google |
| **scope** | string(s) describing specific abilities |
| **auth**orization **url** | where to send initial request + scopes |
| **auth**orization **code** | very temporary key |
| **token url** | where to send authorization code |
| **oauth token**, token | the real key, often with extra info |

::: notes
-   Bold = what I'll call it on other pages
-   Oauth is complicated! Don't feel bad if you're confused!
-   The point of the multiple steps is to make it hard for attacker to intercept, and minimize what they can do if they do
-   Auth code can only be sent to specified URLs
-   The "real key" here is a bearer token.
-   Token often includes a "refresh token", longer-lived shortcut around the auth process.
:::

## The OAuth "dance"

-   **user** to **app**: Hit this API for me!
-   **app** to **host** @ **auth url** (browser): I'm (**client**). Can I act as **user** with these **scopes**?
-   **host** to **user**: Is this ok?
-   **user** to **host**: Yes
-   **host** to **app** (sent to specific address): Your password is **auth code**
-   **app** directly to **host** @ **token url**: Here's my **client** + user's **auth code**
-   **host** directly to **app**: Here's an **oauth token** for that user (and I'll log what it can do)

::: notes
TODO: Image of OAuth dance

-   This is sometimes called 3-legged auth
    -   Took me forever to differentiate "app" from "user" to make the 3 legs make sense
    -   Host is in multiple places but it just counts as one leg
-   Not covered: Then (not much) later app sends bearer token to host with API requests, and host checks that token can do those things.
:::

# Others/Old


## OAuth credential dangers {-}

-   🟢 Client id: Like knowing a package name.
-   🟡 Client secret:
    -   Can pretend to be your client, but user still needs to say ok
    -   Can your **client** do anything special?
        -   Installed (e.g. Slack app)?
        -   API usage limits?
-   🟡 Authorization code: Unlikely to be an issue
    -   Only sent to provided redirect_uri
    -   Extremely short lived (often minutes or less)

## OAuth credential dangers (cont) {-}

-   🟡 Refresh token: A longer-lived authorization code
    -   Can be used to get a new access token
    -   Usually revoked if you auth from scratch
    -   Also need client secret to refresh
-   🟠 Access token: The thing we're protecting
    -   Can do whatever it's authorized to do
    -   Usually easy to revoke
-   🔴 Username + password: We don't want to know these

## httr2::oauth_client() {-}

-   Almost definitely only need these (from API provider):
    -   `id` = Client ID
    -   `token_url` = URL where clients exchange authorization codes for tokens
    -   `secret` = Client secret
    -   Often `auth = "header"`
    -   If this client has multiple uses: `name` = unique for this use case
-   Construct once & reuse

## OAuth client demo {-}

```{r auth-oauth-youtube-client, eval = FALSE}
library(httr2)
yt_client <- oauth_client(
  Sys.getenv("YOUTUBE_CLIENT_ID"), 
  "https://oauth2.googleapis.com/token",
  secret = Sys.getenv("YOUTUBE_CLIENT_SECRET")
)
```

## httr2::req_oauth_auth_code() {-}

-   `auth_url` = URL to get an authorization code (from API)
-   `scope` = Usually comma-separated string of permissions
-   `pkce` = Good if supported, often have to turn off
-   `redirect_uri` = Where to send response
    -   Often need specific local port "http://localhost:4242" or "http://127.0.0.1:4242"
    -   Must be configured as part of client configuration (at API)
-   `cache_disk` = Set this `TRUE` if you can
    -   `cache_key` if you'll use this client for multiple tokens

## Oauth request demo {-}

```{r auth-oauth-youtube-call, eval = FALSE}
playlists <- request("https://youtube.googleapis.com/youtube/v3") |> 
  req_url_path_append("playlists") |> 
  req_url_query(part = "snippet", mine = TRUE, maxResults = 50) |> 
  req_oauth_auth_code(
    yt_client, 
    "https://accounts.google.com/o/oauth2/v2/auth",
    scope = "https://www.googleapis.com/auth/youtube",
    redirect_uri = "http://127.0.0.1:8888"
  ) |> 
  req_perform()
```

## Automating OAuth {-}

-   *If you can,* use httr2 cache: easiest, but
    -   auto-deletes when 30 days old
    -   fills logs w/ "Caching httr2 token in ..." messages
-   `httr2::req_oauth_bearer_jwt()` if you have JSON web token (service account)
-   `httr2::req_oauth_refresh()` if you have a refresh token
    -   `httr2::oauth_flow_auth_code()` once to get refresh

## Browser cookies {-}

*This will feel hacky because it is hacky.*

-   Install [EditThisCookie](https://www.editthiscookie.com/) browser extension
-   Use API in browser
-   Open EditThisCookie extension
-   Options > "Choose the preferred export format for cookies" > Netscape HTTP Cookie File
-   Open EditThisCookie extension
-   Export
-   Paste into a file at `path`
-   `httr2::req_cookie_preserve(req, path)`

## Meeting Videos {-}

### Cohort 1 {-}

`r knitr::include_url("https://www.youtube.com/embed/URL")`

<details>
<summary> Meeting chat log </summary>

```
LOG
```
</details>
