---
engine: knitr
title: How do I tell the API who I am?
---

# ï¸âœ… Learning objectives

::: nonincremental
-   Provide information in your request about how you're accessing the API. 
-   Find authentication information in API docs.
-   Authenticate a request with an API key.
-   Authenticate a request with OAuth.
:::

```{r}
#| label: authentication-packages-used
#| eval: true
#| warning: false
library(httr2)
```

# How can I tell the API how I'm accessing it?

## What is a user agent?

-   "User agent" = software that accesses the web
-   `User-Agent` request header = string IDing the "user agent"
-   {httr2} attaches a default `User-Agent` header

::: fragment
```{r}
httr2::request("https://example.com") |> httr2::req_dry_run()
#> GET / HTTP/1.1
#> Host: example.com
#> User-Agent: httr2/1.0.1 r-curl/5.2.1 libcurl/8.3.0
#> Accept: */*
#> Accept-Encoding: deflate, gzip
```
:::

::: notes
-   It's arguable whether *your code* is the user agent or *httr2* is.
-   Headers are the things at the top of a request, outside the request itself
:::

## Should I override the default user agent?

-   Are you hitting the API a LOT?
-   Are you providing reusable code for others to hit the API?

::: notes
-   Default is fine almost all the time
-   Include UA in package (with option for user to expand)
-   If you use your code repeatedly/automatically, provide a UA
-   Documentation might ask for it (like Jim found in api.crossref.org docs)
:::

## How do I override the default user agent?

`httr2::req_user_agent(req, string = NULL)`

```{r}
#| label: httr2-authentication-req_user_agent
httr2::request("https://example.com") |> 
  httr2::req_user_agent("MyUserAgent/1.0 (more details; separate with ;)") |> 
  httr2::req_dry_run()
#> GET / HTTP/1.1
#> Host: example.com
#> User-Agent: MyUserAgent/1.0 (more details; separate with ;)
#> Accept: */*
#> Accept-Encoding: deflate, gzip
```

## An experimental .Rprofile user agent function

```{r}
#| label: httr2-authentication-.req_ua
.httr2_ua <- function() {
  # Recreate the default httr2 string.
  versions <- c(
    httr2 = as.character(utils::packageVersion("httr2")),
    `r-curl` = as.character(utils::packageVersion("curl")),
    libcurl = curl::curl_version()$version
  )
  paste0(names(versions), "/", versions, collapse = " ")
}
.req_ua <- function(req) {
  httr2_string <- .httr2_ua()
  me <- "Jon Harmon"
  url <- "https://wapir.io"
  email <- "jonthegeek+useragent@gmail.com"
  string <- glue::glue(
    "{httr2_string} ({me}; {url}; mailto:{email})"
  )
  httr2::req_user_agent(req, string = string)
}
```

::: notes
-   Start with `.` so it doesn't show in my environment.
-   In general, UA should tell the API how you're accessing it
:::

# How is this chapter evolving?

-   Slightly less details about why different mechanisms are better/worse
    -   That's more important for {plumber} half
-   Consider wrapping those notes entirely in OAuth explanation
-   Keep the chapter together as a single chapter
    -   This side should be relatively simple
    -   Complexity belongs in {plumber} half

# What is authentication?

::: notes
-   Before we dive into the how-to, let's try to understand why authentication is complicated.
:::


## The 2 auths

::::: columns
:::: column
::: {.fragment fragment-index=0}
Authentication
:::

-   Verifying who you are
-   Uses some sort of "credentials"
::::
:::: column
::: {.fragment fragment-index=1}
Authorization
:::

-   Granting access
::::
:::::

-   Both often abbreviated "auth"
-   Often used interchangeably

::: fragment

> The HTTP *Authorization* request header can be used to provide credentials that *authenticate* a user agent with a server, allowing access to a protected resource.
> â€” [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)

:::

::: notes
-   "TECHNICALLY..."
-   Credentials = username & password, api key, temporary token...
-   "Despite what the internet will insist on telling you..." ("Often used")
-   Mozilla Developer Network (MDN) is pretty much THE reference for these things, and it mixes them.
-   (Learned there that server is *supposed* to send 401 with info about how to auth in `WWW-Authenticate` header! Haven't found an API that actually does that.)
:::

## What are the dangers of leaked creds?

::::: columns
:::: column
::: fragment
How much control does it have?

-   Can it lock you out?
-   Can it reveal sensitive data?
:::
::::
:::: column
::: fragment
How long does it last?

-   Shorter = safer
-   Can you revoke it?
:::
::::
:::::

::: fragment
How likely is it to leak?

-   When do you send it?
-   Where do you send it?
-   How often do you send it?
:::


## Types of authentication

::::: columns
:::: column
::: fragment
ðŸ”´ **HTTP Basic:** username + password sent with request

-   Access entire account
-   Often difficult to turn off
:::
::: fragment
ðŸŸ  **API Key:** password-like thing sent with request

-   Usually key == you
-   You can often revoke
:::
::::
:::: column
::: fragment
ðŸŸ¡ **Bearer Token:** shorter-lived api-key-like thing

-   Different token for different use
-   Often short-lived
:::
::: fragment
ðŸŸ¢ **OAuth:** Multi-step process to generate a key

-   Exists to minimize dangers
-   Multiple short-lived pieces
:::
::::
:::::

::: notes
-   There are other things, but these three cover almost everything.
-   And almost nobody uses the first one for APIs anymore.
-   Oauth not always implemented correctly 
-   Other schemes like api keys in cookies, SSL certs not discussed here
:::

# How can I find authentication information?

## OpenAPI: securitySchemes

If you have the OpenAPI description, use it!

-   `components$securitySchemes` = ways to auth
-   `security` (top level) = default schemes
-   [OpenFEC](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.yaml)
-   [Google Calendar](https://api.apis.guru/v2/specs/googleapis.com/calendar/v3/openapi.yaml)

::: notes
-   Often still necessary to dig through docs for details
:::

## Documentation

-   Sadly, no standard
-   [OpenFEC](https://api.open.fec.gov/developers)
-   [Google Calendar](https://developers.google.com/calendar/api/guides/overview)

# How can I authenticate a request using API keys?

## But first: Practice safe git

-   Run `usethis::git_vaccinate()`
-   Often `usethis::use_git_ignore(".Renviron")`

## What are HTTP request headers?

-   Metadata about the request
-   `httr2::req_headers(.req, ..., .redact = NULL)`
    -   `.req` = a request
    -   `...` = name-value pairs for headers (names are case-insensitive)
    -   `.redact` = character vector of headers to hide in print

## How can I authenticate FECAPI requests?

[OpenFEC OAS](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.yaml)

```{r}
request("https://api.open.fec.gov/v1") |> 
  req_headers("X-Api-Key" = "DEMO_KEY", .redact = "X-Api-Key")

#> <httr2_request>
#> GET https://api.open.fec.gov/v1
#> Headers:
#> â€¢ X-Api-Key: '<REDACTED>'
#> Body: empty
```

## Authenticating with nectar

[{nectar}](https://nectar.api2r.org) ðŸ“¦ wraps {httr2} for packages

```{r}
request("https://api.open.fec.gov/v1") |> 
  nectar::req_auth_api_key(
    location = "header", 
    parameter_name = "X-Api-Key", 
    api_key = "DEMO_KEY"
  )

#> <httr2_request>
#> GET https://api.open.fec.gov/v1
#> Headers:
#> â€¢ X-Api-Key: '<REDACTED>'
#> Body: empty
```

# How can I authenticate a request using OAuth?

-   Next week!
-   Slides still in progress.
-   Also see [httr2 OAuth article](https://httr2.r-lib.org/articles/oauth.html)

## Oauth terminology

| term(s)            | meaning                            |
|--------------------|------------------------------------|
| oauth host         | the API, or a 3rd party like Google |
| client, oauth client, oauth application | you create this at oauth host |
| application | your R code |
| scope | string(s) describing specific abilities |
| authorization url | where to send initial request + scopes |
| authorization code | very temporary key |
| token url | where to send authorization code |
| token | the real key, often with accompanying info |

::: notes
-   Oauth is complicated! Don't feel bad if you're confused!
-   The point of the multiple steps is to make it hard for attacker to intercept, and minimize what they can do if they do
-   Auth code can only be sent to specified URLs
-   Token often includes a "refresh token", longer-lived shortcut around the auth process.
-   Main piece is a bearer token.
:::

# Others/Old

## What are HTTP request headers?

::: fragment
Metadata about the request

-   Authentication
-   Cookies
-   Cache rules
-   Expected response
-   Etc
:::

::: fragment
Names are case-insensitive!
:::

## `req_headers()`

TODO: Leftovers from `httr2.qmd`. Make it fit in this chapter!

::: fragment
```{r}
#| code-line-numbers: "1|1-2"
req_fec_auth <- req_fec |> 
  req_headers("X-Api-Key" = "DEMO_KEY", .redact = "X-Api-Key")
```
:::
::: fragment
```{r}
req_dry_run(req_fec_auth)
```
:::
::: fragment
Be careful!
```{r}
req_fec_auth$headers
```
:::

::: notes
-   `.redact` arg tells it to hide the value of that argument when it prints to the console.
-   `req_dry_run()` prints useful info without actually running `req_perform()`
    -   Normal print of req_fec_auth also works outside of slide context
-   Be careful: It's still in the object, just hidden
:::

## `req_url()`

-   *Replace* entire URL
-   eg: Same authentication, different `base_url` 

::: fragment
```{r}
#| code-line-numbers: "1|1-2"
req_fec_dev_auth <- req_fec_auth |> 
  req_url("https://dev.fec.fake/v1")
```
:::

::: fragment
```{r}
req_dry_run(req_fec_dev_auth)
```

:::

::: notes
-   At first I lumped this in same bucket as req_url_path()
-   YouTube API: metadata vs upload
:::


## What does this API want? {-}

-   Find "OpenAPI" or "Swagger" links (or "API json", "API yaml", etc)
    -   Search for "securitySchemes"
    -   Often easier-to-understand details than docs!
-   Might need to do something to "register"
    -   "Request an API key"
    -   "Register your App" (or "Client") (see OAuth)

## HTTP Basic Authentication {-} 

-   `httr2::req_auth_basic(req, username, password = NULL)`
-   Leave password blank: Prompt interactive semi-securely
-   Avoid using this if you can!
    -   I can't remember any API that only offers this

## API Keys & Bearer Tokens {-}

-   `httr2::req_auth_bearer_token(req, token)` (specific header)
    -   Pass `token` as `Sys.get("API_TOKEN_NAME")`
    -   Save token with `usethis::edit_r_environ()`
-   Catch-all: `httr2::req_headers(.req, ..., .redact = NULL)`
    -   `...` = `token_parameter = Sys.get("API_TOKEN_NAME")`
    -   `.redact = "token_parameter"` to hide in print

## The OAuth "dance" {-}

-   User to client: Hit this API for me!
-   Client (ID) to auth: Can I act as this user and do these things?
-   Auth to user: Is this ok?
-   User to auth: Yes
-   Auth to client's home address: Use this to get a key
-   Client (ID + secret) to auth2: Turn this into a key (I'm really me!)
-   Auth2 to client: Here's your key (and I'll log what it can do)
-   Client to API: Here's my key
-   API to auth: Can this key do this?
-   Auth to API: (checks logged scopes) Yes!
-   API to client: Ok, here's the info!

TODO: Image of OAuth dance

## OAuth credential dangers {-}

-   ðŸŸ¢ Client id: Like knowing a package name.
-   ðŸŸ¡ Client secret:
    -   Can pretend to be your client, but user still needs to say ok
    -   Can your **client** do anything special?
        -   Installed (e.g. Slack app)?
        -   API usage limits?
-   ðŸŸ¡ Authorization code: Unlikely to be an issue
    -   Only sent to provided redirect_uri
    -   Extremely short lived (often minutes or less)

## OAuth credential dangers (cont) {-}

-   ðŸŸ¡ Refresh token: A longer-lived authorization code
    -   Can be used to get a new access token
    -   Usually revoked if you auth from scratch
    -   Also need client secret to refresh
-   ðŸŸ  Access token: The thing we're protecting
    -   Can do whatever it's authorized to do
    -   Usually easy to revoke
-   ðŸ”´ Username + password: We don't want to know these

## httr2::oauth_client() {-}

-   Almost definitely only need these (from API provider):
    -   `id` = Client ID
    -   `token_url` = URL where clients exchange authorization codes for tokens
    -   `secret` = Client secret
    -   Often `auth = "header"`
    -   If this client has multiple uses: `name` = unique for this use case
-   Construct once & reuse

## OAuth client demo {-}

```{r auth-oauth-youtube-client, eval = FALSE}
library(httr2)
yt_client <- oauth_client(
  Sys.getenv("YOUTUBE_CLIENT_ID"), 
  "https://oauth2.googleapis.com/token",
  secret = Sys.getenv("YOUTUBE_CLIENT_SECRET")
)
```

## httr2::req_oauth_auth_code() {-}

-   `auth_url` = URL to get an authorization code (from API)
-   `scope` = Usually comma-separated string of permissions
-   `pkce` = Good if supported, often have to turn off
-   `redirect_uri` = Where to send response
    -   Often need specific local port "http://localhost:4242" or "http://127.0.0.1:4242"
    -   Must be configured as part of client configuration (at API)
-   `cache_disk` = Set this `TRUE` if you can
    -   `cache_key` if you'll use this client for multiple tokens

## Oauth request demo {-}

```{r auth-oauth-youtube-call, eval = FALSE}
playlists <- request("https://youtube.googleapis.com/youtube/v3") |> 
  req_url_path_append("playlists") |> 
  req_url_query(part = "snippet", mine = TRUE, maxResults = 50) |> 
  req_oauth_auth_code(
    yt_client, 
    "https://accounts.google.com/o/oauth2/v2/auth",
    scope = "https://www.googleapis.com/auth/youtube",
    redirect_uri = "http://127.0.0.1:8888"
  ) |> 
  req_perform()
```

## Automating OAuth {-}

-   *If you can,* use httr2 cache: easiest, but
    -   auto-deletes when 30 days old
    -   fills logs w/ "Caching httr2 token in ..." messages
-   `httr2::req_oauth_bearer_jwt()` if you have JSON web token (service account)
-   `httr2::req_oauth_refresh()` if you have a refresh token
    -   `httr2::oauth_flow_auth_code()` once to get refresh

## Browser cookies {-}

*This will feel hacky because it is hacky.*

-   Install [EditThisCookie](https://www.editthiscookie.com/) browser extension
-   Use API in browser
-   Open EditThisCookie extension
-   Options > "Choose the preferred export format for cookies" > Netscape HTTP Cookie File
-   Open EditThisCookie extension
-   Export
-   Paste into a file at `path`
-   `httr2::req_cookie_preserve(req, path)`

## Meeting Videos {-}

### Cohort 1 {-}

`r knitr::include_url("https://www.youtube.com/embed/URL")`

<details>
<summary> Meeting chat log </summary>

```
LOG
```
</details>
