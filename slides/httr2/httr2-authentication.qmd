---
engine: knitr
title: How do I tell the API who I am?
---

# ️✅ Learning objectives

::: nonincremental
-   Provide information in your request about how you're accessing the API. 
-   Find authentication information in API docs.
-   Authenticate a request with an API key.
-   Authenticate a request with OAuth.
:::

```{r}
#| label: authentication-packages-used
#| eval: true
#| warning: false
library(httr2)
```

# How can I tell the API how I'm accessing it?

## What is a user agent?

-   "User agent" = software that accesses the web
-   `User-Agent` request header = string IDing the "user agent"
-   {httr2} attaches a default `User-Agent` header

::: fragment
```{r}
httr2::request("https://example.com") |> httr2::req_dry_run()
#> GET / HTTP/1.1
#> Host: example.com
#> User-Agent: httr2/1.0.1 r-curl/5.2.1 libcurl/8.3.0
#> Accept: */*
#> Accept-Encoding: deflate, gzip
```
:::

::: notes
-   It's arguable whether *your code* is the user agent or *httr2* is.
-   Headers are the things at the top of a request, outside the request itself
:::

## Should I override the default user agent?

-   Are you hitting the API a LOT?
-   Are you providing reusable code for others to hit the API?

::: notes
-   Default is fine almost all the time
-   Include UA in package (with option for user to expand)
-   If you use your code repeatedly/automatically, provide a UA
-   Documentation might ask for it (like Jim found in api.crossref.org docs)
:::

## How do I override the default user agent?

`httr2::req_user_agent(req, string = NULL)`

```{r}
#| label: httr2-authentication-req_user_agent
httr2::request("https://example.com") |> 
  httr2::req_user_agent("MyUserAgent/1.0 (more details; separate with ;)") |> 
  httr2::req_dry_run()
#> GET / HTTP/1.1
#> Host: example.com
#> User-Agent: MyUserAgent/1.0 (more details; separate with ;)
#> Accept: */*
#> Accept-Encoding: deflate, gzip
```

## An experimental .Rprofile user agent function

```{r}
#| label: httr2-authentication-.req_ua
.httr2_ua <- function() {
  # Recreate the default httr2 string.
  versions <- c(
    httr2 = as.character(utils::packageVersion("httr2")),
    `r-curl` = as.character(utils::packageVersion("curl")),
    libcurl = curl::curl_version()$version
  )
  paste0(names(versions), "/", versions, collapse = " ")
}
.req_ua <- function(req) {
  httr2_string <- .httr2_ua()
  me <- "Jon Harmon"
  url <- "https://wapir.io"
  email <- "jonthegeek+useragent@gmail.com"
  string <- glue::glue(
    "{httr2_string} ({me}; {url}; mailto:{email})"
  )
  httr2::req_user_agent(req, string = string)
}
```

::: notes
-   Start with `.` so it doesn't show in my environment.
-   In general, UA should tell the API how you're accessing it
:::

# How can I find authentication information?

## What is authentication?

-   **Authentication:** Verifying who you are.
-   **Authorization:** Granting permissions to do things (based on authentication)
-   **Auth:** Used interchangeably for both

::: notes
-   Internet makes a big deal about this distinction if you Google
-   For users, the difference doesn't matter
    -   You auth with the server so the server will auth you
:::

## What are some types of authentication?

::: fragment
🔴 **HTTP Basic:** username + password sent with request
:::
::: fragment
|         📜 *deed to your house*
:::
::: fragment
🟠 **API Key:** password-like thing sent with request
:::
::: fragment
|         🔑 *key to your house*
:::
::: fragment
🟡 **Bearer Token:** shorter-lived, limited key
:::
::: fragment
|         💳 *keycard*
:::
::: fragment
🟢 **OAuth:** multistep process to generate a key
:::
::: fragment
|         🕵️ *background check to issue keycard*
:::

::: notes
-   Almost nobody uses HTTP basic for APIs anymore.
-   If you gave an ex a key to your house, you can change the lock without disrupting your life too much
-   Keycard can be limited to open certain doors, not open others
-   End result of OAuth is a bearer token
-   There are other things, but these four cover almost everything.
-   Other schemes like api keys in cookies, SSL certs not discussed here
:::

## Documentation

-   Sadly, no standard
-   [OpenFEC](https://api.open.fec.gov/developers)
-   [Google Calendar](https://developers.google.com/calendar/api/guides/overview)

::: notes
-   Usually either at top of docs or in each relevant endpoint
-   Sometimes different endpoints have different requirements (particularly OAuth scopes, more below)
-   Often docs give the basics, but might not have all details for actually using OAuth in code, for example.
:::

## OpenAPI: securitySchemes

If you have the OpenAPI description, use it!

-   `components$securitySchemes` = ways to auth
-   `security` (top level) = default schemes
-   [OpenFEC](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.yaml)
-   [Google Calendar](https://api.apis.guru/v2/specs/googleapis.com/calendar/v3/openapi.yaml)

::: notes
-   Often still necessary to dig through docs for details
:::

# How can I prepare my system for authentication?

## Practice safe git

## Use keyring


# How can I authenticate a request using API keys?

## But first: Practice safe git

-   Run `usethis::git_vaccinate()`
-   Often `usethis::use_git_ignore(".Renviron")`
-   `install.packages("keyring")`

::: notes
-   httr2 actually puts auth info in a more-secure, harder-to-check-in place.
-   We'll often put keys in personal .Renviron, but you might want a project-specific one for special keys.
-   Even better: use {keyring} (TODO: Go down this rabbit hole!)
:::

## What are HTTP request headers?

-   Metadata about the request
-   `httr2::req_headers(.req, ..., .redact = NULL)`
    -   `.req` = a request
    -   `...` = name-value pairs for headers (names are case-insensitive)
    -   `.redact` = character vector of headers to hide in print

## How can I authenticate FECAPI requests?

[OpenFEC OAS](https://api.apis.guru/v2/specs/fec.gov/1.0/openapi.yaml)

```{r}
request("https://api.open.fec.gov/v1") |> 
  req_headers("X-Api-Key" = "DEMO_KEY", .redact = "X-Api-Key")

#> <httr2_request>
#> GET https://api.open.fec.gov/v1
#> Headers:
#> • X-Api-Key: '<REDACTED>'
#> Body: empty
```

## Authenticating with nectar

[{nectar}](https://nectar.api2r.org) 📦 wraps {httr2} for packages

```{r}
request("https://api.open.fec.gov/v1") |> 
  nectar::req_auth_api_key(
    location = "header", 
    parameter_name = "X-Api-Key", 
    api_key = "DEMO_KEY"
  )

#> <httr2_request>
#> GET https://api.open.fec.gov/v1
#> Headers:
#> • X-Api-Key: '<REDACTED>'
#> Body: empty
```

# How can I authenticate a request using OAuth?

-   Next week!
-   Slides still in progress.
-   Also see [httr2 OAuth article](https://httr2.r-lib.org/articles/oauth.html)

## Oauth terminology

| term(s)            | meaning                            |
|--------------------|------------------------------------|
| oauth host         | the API, or a 3rd party like Google |
| client, oauth client, oauth application | you create this at oauth host |
| application | your R code |
| scope | string(s) describing specific abilities |
| authorization url | where to send initial request + scopes |
| authorization code | very temporary key |
| token url | where to send authorization code |
| token | the real key, often with accompanying info |

::: notes
-   Oauth is complicated! Don't feel bad if you're confused!
-   The point of the multiple steps is to make it hard for attacker to intercept, and minimize what they can do if they do
-   Auth code can only be sent to specified URLs
-   Token often includes a "refresh token", longer-lived shortcut around the auth process.
-   Main piece is a bearer token.
:::

# Others/Old

## What are HTTP request headers?

::: fragment
Metadata about the request

-   Authentication
-   Cookies
-   Cache rules
-   Expected response
-   Etc
:::

::: fragment
Names are case-insensitive!
:::

## `req_headers()`

TODO: Leftovers from `httr2.qmd`. Make it fit in this chapter!

::: fragment
```{r}
#| code-line-numbers: "1|1-2"
req_fec_auth <- req_fec |> 
  req_headers("X-Api-Key" = "DEMO_KEY", .redact = "X-Api-Key")
```
:::
::: fragment
```{r}
req_dry_run(req_fec_auth)
```
:::
::: fragment
Be careful!
```{r}
req_fec_auth$headers
```
:::

::: notes
-   `.redact` arg tells it to hide the value of that argument when it prints to the console.
-   `req_dry_run()` prints useful info without actually running `req_perform()`
    -   Normal print of req_fec_auth also works outside of slide context
-   Be careful: It's still in the object, just hidden
:::

## `req_url()`

-   *Replace* entire URL
-   eg: Same authentication, different `base_url` 

::: fragment
```{r}
#| code-line-numbers: "1|1-2"
req_fec_dev_auth <- req_fec_auth |> 
  req_url("https://dev.fec.fake/v1")
```
:::

::: fragment
```{r}
req_dry_run(req_fec_dev_auth)
```

:::

::: notes
-   At first I lumped this in same bucket as req_url_path()
-   YouTube API: metadata vs upload
:::


## What does this API want? {-}

-   Find "OpenAPI" or "Swagger" links (or "API json", "API yaml", etc)
    -   Search for "securitySchemes"
    -   Often easier-to-understand details than docs!
-   Might need to do something to "register"
    -   "Request an API key"
    -   "Register your App" (or "Client") (see OAuth)

## HTTP Basic Authentication {-} 

-   `httr2::req_auth_basic(req, username, password = NULL)`
-   Leave password blank: Prompt interactive semi-securely
-   Avoid using this if you can!
    -   I can't remember any API that only offers this

## API Keys & Bearer Tokens {-}

-   `httr2::req_auth_bearer_token(req, token)` (specific header)
    -   Pass `token` as `Sys.get("API_TOKEN_NAME")`
    -   Save token with `usethis::edit_r_environ()`
-   Catch-all: `httr2::req_headers(.req, ..., .redact = NULL)`
    -   `...` = `token_parameter = Sys.get("API_TOKEN_NAME")`
    -   `.redact = "token_parameter"` to hide in print

## The OAuth "dance" {-}

-   User to client: Hit this API for me!
-   Client (ID) to auth: Can I act as this user and do these things?
-   Auth to user: Is this ok?
-   User to auth: Yes
-   Auth to client's home address: Use this to get a key
-   Client (ID + secret) to auth2: Turn this into a key (I'm really me!)
-   Auth2 to client: Here's your key (and I'll log what it can do)
-   Client to API: Here's my key
-   API to auth: Can this key do this?
-   Auth to API: (checks logged scopes) Yes!
-   API to client: Ok, here's the info!

TODO: Image of OAuth dance

## OAuth credential dangers {-}

-   🟢 Client id: Like knowing a package name.
-   🟡 Client secret:
    -   Can pretend to be your client, but user still needs to say ok
    -   Can your **client** do anything special?
        -   Installed (e.g. Slack app)?
        -   API usage limits?
-   🟡 Authorization code: Unlikely to be an issue
    -   Only sent to provided redirect_uri
    -   Extremely short lived (often minutes or less)

## OAuth credential dangers (cont) {-}

-   🟡 Refresh token: A longer-lived authorization code
    -   Can be used to get a new access token
    -   Usually revoked if you auth from scratch
    -   Also need client secret to refresh
-   🟠 Access token: The thing we're protecting
    -   Can do whatever it's authorized to do
    -   Usually easy to revoke
-   🔴 Username + password: We don't want to know these

## httr2::oauth_client() {-}

-   Almost definitely only need these (from API provider):
    -   `id` = Client ID
    -   `token_url` = URL where clients exchange authorization codes for tokens
    -   `secret` = Client secret
    -   Often `auth = "header"`
    -   If this client has multiple uses: `name` = unique for this use case
-   Construct once & reuse

## OAuth client demo {-}

```{r auth-oauth-youtube-client, eval = FALSE}
library(httr2)
yt_client <- oauth_client(
  Sys.getenv("YOUTUBE_CLIENT_ID"), 
  "https://oauth2.googleapis.com/token",
  secret = Sys.getenv("YOUTUBE_CLIENT_SECRET")
)
```

## httr2::req_oauth_auth_code() {-}

-   `auth_url` = URL to get an authorization code (from API)
-   `scope` = Usually comma-separated string of permissions
-   `pkce` = Good if supported, often have to turn off
-   `redirect_uri` = Where to send response
    -   Often need specific local port "http://localhost:4242" or "http://127.0.0.1:4242"
    -   Must be configured as part of client configuration (at API)
-   `cache_disk` = Set this `TRUE` if you can
    -   `cache_key` if you'll use this client for multiple tokens

## Oauth request demo {-}

```{r auth-oauth-youtube-call, eval = FALSE}
playlists <- request("https://youtube.googleapis.com/youtube/v3") |> 
  req_url_path_append("playlists") |> 
  req_url_query(part = "snippet", mine = TRUE, maxResults = 50) |> 
  req_oauth_auth_code(
    yt_client, 
    "https://accounts.google.com/o/oauth2/v2/auth",
    scope = "https://www.googleapis.com/auth/youtube",
    redirect_uri = "http://127.0.0.1:8888"
  ) |> 
  req_perform()
```

## Automating OAuth {-}

-   *If you can,* use httr2 cache: easiest, but
    -   auto-deletes when 30 days old
    -   fills logs w/ "Caching httr2 token in ..." messages
-   `httr2::req_oauth_bearer_jwt()` if you have JSON web token (service account)
-   `httr2::req_oauth_refresh()` if you have a refresh token
    -   `httr2::oauth_flow_auth_code()` once to get refresh

## Browser cookies {-}

*This will feel hacky because it is hacky.*

-   Install [EditThisCookie](https://www.editthiscookie.com/) browser extension
-   Use API in browser
-   Open EditThisCookie extension
-   Options > "Choose the preferred export format for cookies" > Netscape HTTP Cookie File
-   Open EditThisCookie extension
-   Export
-   Paste into a file at `path`
-   `httr2::req_cookie_preserve(req, path)`

## Meeting Videos {-}

### Cohort 1 {-}

`r knitr::include_url("https://www.youtube.com/embed/URL")`

<details>
<summary> Meeting chat log </summary>

```
LOG
```
</details>
